---
layout: post
title: "什么是驱动框架？"
keywords: ["驱动框架"]
description: "驱动框架简介"
categories: "led"
tags: ["linux驱动"]
author: ["ByteJog"]
permalink: /new-post.html
---
## Linux驱动框架简介
在Linux驱动开发中，涉及3类设备：字符设备、块设备和网络设备。但是在具体的开发过程中，Linux内核对各种硬件进行了分类，然后针对各类硬件实现一套比较标准的驱动框架，其中每类硬件共有属性那一部分由内核开发者负责实现和维护，然后给驱动开发者留出接口用来完成具体硬件的特定操作部分，这更加简化了驱动开发者的编码工作。

什么意思呢？比如，led归属于字符设备，我们可以从头到尾按照字符设备的编写流程（创建字符设备、设备、类、file_operations结构）来开发，但是这样比较繁琐，Linux内核针j将led设备归属于leds类，并提供led驱动框架来点亮led灯。它只需要调用一个注册设备的接口就可以取代之前手动创建字符设备、设备类、file_operations结构的过程。

如果要使用leds驱动框架，首先要在内核中开启相关的配置宏：

    Device Drivers  --->    	[*] LED Support  --->    		   LED Class Support

启动内核后可以在/sys/class/目录下看到leds类，这也就是驱动框架中内核开发者完成的那一部分，之前是需要驱动开发者自己创建的，现在对于驱动开发者来说就只需要调用相关的接口创建设备即可。

下面是使用led框架开发led设备驱动的一个例子：

````c
struct self2021_led {
	struct i2c_client *client;
	struct led_classdev cdev;
	struct work_struct brightness_work;
	struct mutex lock;
};

static void self2021_brightness_work(struct work_struct *work)
{
    
}

static void self2021_set_brightness(struct led_classdev *cdev, enum led_brightness brightness)
{
	struct self2021_led *led = container_of(cdev, struct self2021_led, cdev);

	led->cdev.brightness = brightness;

	schedule_work(&led->brightness_work);
}

static int self2021_led_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	struct self2021_led *led;

	led = devm_kzalloc(&client->dev, sizeof(struct self2021_led), GFP_KERNEL);
	if (!led)
		return -ENOMEM;

	led->client = client;

	mutex_init(&led->lock);

	INIT_WORK(&led->brightness_work, self2021_brightness_work);

	led->cdev.brightness_set = self2021_set_brightness;

	ret = led_classdev_register(&led->client->dev, &led->cdev);

	i2c_set_clientdata(client, led);

	return 0;
}

static int self2021_led_remove(struct i2c_client *client)
{
	struct self2021_led *led = i2c_get_clientdata(client);
    led_classdev_unregister(&led.cdev);
	mutex_destroy(&led->lock);
	return 0;
}

static const struct i2c_device_id self2021_led_id[] = {
	{"self2021_led", 0},
	{},
};

MODULE_DEVICE_TABLE(i2c, self2021_led_id);

static struct of_device_id self2021_match_table[] = {
	{ .compatible = "awinic,self2021",},
	{ },
};

static struct i2c_driver self2021_led_driver = {
	.probe = self2021_led_probe,
	.remove = self2021_led_remove,
	.driver = {
		.name = "self2021_led",
		.owner = THIS_MODULE,
		.of_match_table = of_match_ptr(self2021_match_table),
	},
	.id_table = self2021_led_id,
};

static int __init self2021_led_init(void)
{
	return i2c_add_driver(&self2021_led_driver);
}
module_init(self2021_led_init);

static void __exit self2021_led_exit(void)
{
	i2c_del_driver(&self2021_led_driver);
}
module_exit(self2021_led_exit);

MODULE_DESCRIPTION("AWINIC aw2013 LED driver");
MODULE_LICENSE("GPL v2");

````

在上述框架中，使用led框架中的注册和删除设备的函数。

在leds类下面创建设备：

````
static inline int led_classdev_register(struct device *parent,struct led_classdev *led_cdev)
````

在leds类下面删除设备：

````
void led_classdev_unregister(struct led_classdev *led_cdev)
````

使用了驱动框架后可以不需要编写应用程序就可以测试led是否能正常被点亮与熄灭，这些都可以在sysfs文件系统中完成。在装载驱动后可以在/sys/class/leds/目录下看到对应的led设备目录，如本文中的self2021_led(填充设备时的设备名字段)。

````
ls /sys/class/leds/led3brightness      power           ueventmax_brightness  subsystem
````

使用echo命令操作led灯：

````
echo 1 > brightness //点亮led 
echo 0 > brightness	//熄灭led 
````
